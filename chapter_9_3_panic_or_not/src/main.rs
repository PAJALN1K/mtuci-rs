// Что лучше: возвращать panic! или Result? В первом случае мы по сути полностью прервем код без
// возможности восстановиться или исправить проблему, в отличие от второго. Поэтому чаще всего 
// лучше пользоваться именно Result. 

// Тем не менее, существует ряд ситуаций, когда лучше использовать panic!, а не Result


// Пример 1

// Когда вы пишете пример, иллюстрирующий некоторую концепцию, наличие хорошего кода обработки 
// ошибок может сделать пример менее понятным.


// Пример 2

// Также было бы целесообразно вызывать unwrap или expect когда у вас есть какая-то другая логика, 
// которая гарантирует, что Result будет иметь значение Ok, но вашу логику не понимает компилятор.

// fn main() {
//     use std::net::IpAddr;

//     let home: IpAddr = "127.0.0.1"
//         .parse()
//         .expect("Hardcoded IP address should be valid");
// }

// Мы создаём экземпляр IpAddr, анализируя жёстко закодированную строку. Можно увидеть, что 127.0.0.1 
// является действительным IP-адресом, поэтому здесь допустимо использование expect. 
// Если строка IP-адреса пришла от пользователя, то она не является жёстко запрограммированной в 
// программе и, следовательно, может привести к ошибке, мы определённо хотели бы обработать Result 
// более надёжным способом. Упоминание предположения о том, что этот IP-адрес жёстко закодирован, 
// побудит нас изменить expect для лучшей обработки ошибок, если в будущем нам потребуется вместо этого 
// получить IP-адрес из какого-либо другого источника.


// Пример 3

// Желательно, чтобы код паниковал, если он может оказаться в некорректном состоянии. В этом контексте 
// некорректное состояние это когда некоторое допущение, гарантия, контракт или инвариант были нарушены. 
// Например, когда недопустимые, противоречивые или пропущенные значения передаются в ваш код - плюс 
// один или несколько пунктов из следующего перечисленного в списке:

// - Некорректное состояние — это что-то неожиданное, отличается от того, что может происходить время от 
// времени, например, когда пользователь вводит данные в неправильном формате.
// - Ваш код после этой точки должен полагаться на то, что он не находится в не корректном состоянии, 
// вместо проверок наличия проблемы на каждом этапе.
// - Нет хорошего способа закодировать данную информацию в типах, которые вы используете.


// Пример 4

// Вариант 1

// use rand::Rng;
// use std::cmp::Ordering;
// use std::io;

// fn main() {
//     println!("Guess the number!");

//     let secret_number = rand::thread_rng().gen_range(1..=100);

//     loop {
//         // --snip--

//         println!("Please input your guess.");

//         let mut guess = String::new();

//         io::stdin()
//             .read_line(&mut guess)
//             .expect("Failed to read line");

//         let guess: i32 = match guess.trim().parse() {
//             Ok(num) => num,
//             Err(_) => continue,
//         };

//         if guess < 1 || guess > 100 {
//             println!("The secret number will be between 1 and 100.");
//             continue;
//         }

//         match guess.cmp(&secret_number) {
//             // --snip--
//             Ordering::Less => println!("Too small!"),
//             Ordering::Greater => println!("Too big!"),
//             Ordering::Equal => {
//                 println!("You win!");
//                 break;
//             }
//         }
//     }
// }

// Однако это не идеальное решение: если бы было чрезвычайно важно, чтобы программа работала только со 
// значениями от 1 до 100, существовало бы много функций, требующих этого, то такая проверка в каждой 
// функции была бы утомительной (и могла бы отрицательно повлиять на производительность).

// Вместо этого можно создать новый тип и поместить проверки в функцию создания экземпляра этого типа, 
// не повторяя их везде. Таким образом, функции могут использовать новый тип в своих сигнатурах и быть 
// уверены в значениях, которые им передают. Листинг 9-13 показывает один из способов, как определить 
// тип Guess, чтобы экземпляр Guess создавался только при условии, что функция new получает значение 
// от 1 до 100.

// Вариант 2

// Тип Guess, который будет создавать экземпляры только для значений от 1 до 100

#![allow(unused)]
fn main() {
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
}