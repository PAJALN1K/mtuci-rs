// Разделение модулей на разные файлы

// До сих пор все примеры в этой главе определяли несколько модулей в одном файле. Когда модули становятся большими, 
// вы можете захотеть переместить их определения в отдельные файлы, чтобы упростить навигацию по коду.

// Например, давайте начнём с кода из листинга 7-17, в котором было несколько модулей ресторана. Мы будем извлекать 
// модули в файлы вместо того, чтобы определять все модули в корневом модуле крейта. В нашем случае корневой модуль 
// крейта - src/lib.rs, но это разделение также работает и с бинарными крейтами, у которых корневой модуль крейта — 
// src/main.rs.

// Сначала мы извлечём модуль front_of_house в свой собственный файл. Удалите код внутри фигурных скобок для модуля 
// front_of_house, оставив только объявление mod front_of_house;, так что теперь src/lib.rs содержит код, показанный в 
// примере 1. Обратите внимание, что этот вариант не скомпилируется, пока мы не создадим файл src/front_of_house.rs 
// из примера 2

// Пример 1

// mod front_of_house;

// pub use crate::front_of_house::hosting;

// pub fn eat_at_restaurant() {
//     hosting::add_to_waitlist();
// }

// [продолжение в front_of_house.rs]

// Обратите внимание, что вам нужно только один раз загрузить файл с помощью объявления mod в вашем дереве модулей. 
// Как только компилятор узнает, что файл является частью проекта (и узнает, где в дереве модулей находится код из-за 
// того, куда вы поместили оператор mod), другие файлы в вашем проекте должны ссылаться на код загруженного файла, 
// используя путь к месту, где он был объявлен, как описано в разделе «Пути для ссылки на элемент в дереве модулей». 
// Другими словами, mod — это не операция «включения», которую вы могли видеть в других языках программирования.



// Альтернативные пути к файлам

// До сих пор мы рассматривали наиболее идиоматические пути к файлам, используемые компилятором Rust, но Rust также поддерживает 
// и старый стиль пути к файлу. 

// Для модуля с именем front_of_house, объявленного в корневом модуле крейта, компилятор будет искать код модуля в:
// src/front_of_house.rs (что мы рассматривали)
// src/front_of_house/mod.rs (старый стиль, всё ещё поддерживаемый путь)

// Для модуля с именем hosting, который является подмодулем front_of_house, компилятор будет искать код модуля в:
// src/front_of_house/hosting.rs (что мы рассматривали)
// src/front_of_house/hosting/mod.rs (старый стиль, всё ещё поддерживаемый путь)

// Если вы используете оба стиля для одного и того же модуля, вы получите ошибку компилятора. Использование сочетания обоих 
// стилей для разных модулей в одном проекте разрешено, но это может сбивать с толку людей, перемещающихся по вашему проекту.

// Основным недостатком стиля, в котором используются файлы с именами mod.rs, является то, что в вашем проекте может оказаться 
// много файлов с именами mod.rs, что может привести к путанице, если вы одновременно откроете их в редакторе.

// Мы перенесли код каждого модуля в отдельный файл, а дерево модулей осталось прежним. Вызовы функций в eat_at_restaurant 
// будут работать без каких-либо изменений, несмотря на то, что определения находятся в разных файлах. Этот метод позволяет 
// перемещать модули в новые файлы по мере увеличения их размеров.

// Обратите внимание, что оператор pub use crate::front_of_house::hosting в src/lib.rs также не изменился, и use не влияет 
// на то, какие файлы компилируются как часть крейта. Ключевое слово mod объявляет модули, и Rust ищет в файле с тем же именем, 
// что и у модуля, код, который входит в этот модуль.
