// Стандартная библиотека содержит несколько полезных структур данных, которые называются коллекциями. 
// Большая часть других типов данных представляют собой хранение конкретного значения, но особенностью 
// коллекций является хранение множества однотипных значений.

// - Вектор (vector) - позволяет нам сохранять различное количество последовательно хранящихся значений,
// - Строка (string) - это последовательность символов. Мы же упоминали тип String ранее, но в данной 
// главе мы поговорим о нем подробнее.
// - Хеш-таблица (hash map) - коллекция которая позволяет хранить перечень ассоциаций значения с ключом 
// (перечень пар ключ:значение). Является конкретной реализацией более общей структуры данных называемой map.


// Первым типом коллекции, который мы разберём, будет Vec<T>, также известный как вектор (vector). 
// Векторы позволяют хранить более одного значения в единой структуре данных, хранящей элементы в памяти 
// один за другим. Векторы могут хранить данные только одного типа. Их удобно использовать, когда нужно 
// хранить список элементов, например, список текстовых строк из файла, или список цен товаров в корзине 
// покупок.


// Пример 1

// Создание нового пустого вектора для хранения значений типа i32

// Векторы реализованы с использованием обобщённых типов. А пока знайте, что тип Vec<T>, предоставляемый 
// стандартной библиотекой, может хранить любой тип.

// fn main() {
//     let v: Vec<i32> = Vec::new();
// }


// Пример 2

// Поскольку мы указали начальные значения типа i32, Rust может сделать вывод, что тип переменной v это 
// Vec<i32> и аннотация типа здесь не нужна. Далее мы посмотрим как изменять вектор.

// fn main() {
//     let v = vec![1, 2, 3];
// }


// Пример 3

// Использование метода push для добавления значений в вектор

// fn main() {
//     let mut v = Vec::new();

//     v.push(5);
//     v.push(6);
//     v.push(7);
//     v.push(8);
// }


// Пример 4

// Есть два способа сослаться на значение, хранящееся в векторе: с помощью индекса или метода get.

// Когда мы используем метод get содержащего индекс, переданный в качестве аргумента, мы получаем 
// тип Option<&T>, который мы можем проверить с помощью match.

// fn main() {
//     let v = vec![1, 2, 3, 4, 5];

//     let third: &i32 = &v[2];
//     println!("The third element is {third}");

//     let third: Option<&i32> = v.get(2);
//     match third {
//         Some(third) => println!("The third element is {third}"),
//         None => println!("There is no third element."),
//     }
// }


// Пример 5

// Причина, по которой Rust предоставляет два способа ссылки на элемент, заключается в том, что вы 
// можете выбрать, как программа будет себя вести, когда вы попытаетесь использовать значение индекса 
// за пределами диапазона существующих элементов.

// [Вызовет панику]

// fn main() {
//     let v = vec![1, 2, 3, 4, 5];

//     let does_not_exist = &v[100];
//     let does_not_exist = v.get(100);
// }

// Когда мы запускаем этот код, первая строка с &v[100] вызовет панику программы, потому что происходит 
// попытка получить ссылку на несуществующий элемент. Такой подход лучше всего использовать, когда вы хотите, 
// чтобы ваша программа аварийно завершила работу при попытке доступа к элементу за пределами вектора.

// Когда методу get передаётся индекс, который находится за пределами вектора, он без паники возвращает None. 
// Вы могли бы использовать такой подход, если доступ к элементу за пределами диапазона вектора происходит 
// время от времени при нормальных обстоятельствах.


// Пример 6

// Когда у программы есть действительная ссылка, borrow checker (средство проверки заимствований), 
// обеспечивает соблюдение правил владения и заимствования, чтобы гарантировать, что эта 
// ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое 
// гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило 
// применяется в примере 6, где мы храним неизменяемую ссылку на первый элемент вектора и затем пытаемся 
// добавить элемент в конец вектора. Данная программа не будет работать.

// fn main() {
//     let mut v = vec![1, 2, 3, 4, 5];

//     let first = &v[0];

//     v.push(6);

//     println!("The first element is: {first}");
// }

// Эта ошибка возникает из-за особенности того, как работают векторы: поскольку векторы размещают значения 
// в памяти друг за другом, добавление нового элемента в конец вектора может потребовать выделения новой 
// памяти и копирования старых элементов в новое пространство, если нет достаточного места, чтобы разместить 
// все элементы друг за другом там, где в данный момент хранится вектор. В этом случае ссылка на первый 
// элемент будет указывать на освобождённую память. Правила заимствования предотвращают попадание программ 
// в такую ситуацию.


// Пример 7

// Печать каждого элемента вектора при помощи итерирования по элементам вектора с помощью цикла for

fn main() {
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }

}


// Пример 8

// Итерирование и изменение элементов вектора по изменяемым ссылкам

// Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать оператор 
// разыменования ссылки * для получения значения по ссылке в переменной i прежде чем использовать 
// оператор +=.

// fn main() {
//     let mut v = vec![100, 32, 57];
//     for i in &mut v {
//         *i += 50;
//     }
// }

// Перебор вектора, будь то неизменяемый или изменяемый, безопасен из-за правил проверки заимствования. 
// Если бы мы попытались вставить или удалить элементы в телах цикла for в листингах 8-7 и 8-8, мы бы 
// получили ошибку компилятора, подобную той, которую мы получили с кодом в листинге 8-6. Ссылка на вектор, 
// содержащийся в цикле for, предотвращает одновременную модификацию всего вектора.


// Пример 9

// Векторы могут хранить значения только одинакового типа. Это может быть неудобно; определённо могут быть 
// случаи когда надо хранить список элементов разных типов. К счастью, варианты перечисления определены для 
// одного и того же типа перечисления, поэтому, когда нам нужен один тип для представления элементов разных 
// типов, мы можем определить и использовать перечисление!

// Rust должен знать, какие типы будут в векторе во время компиляции, чтобы точно знать сколько памяти в 
// куче потребуется для хранения каждого элемента. Мы также должны чётко указать, какие типы разрешены в 
// этом векторе.

// fn main() {
//     enum SpreadsheetCell {
//         Int(i32),
//         Float(f64),
//         Text(String),
//     }

//     let row = vec![
//         SpreadsheetCell::Int(3),
//         SpreadsheetCell::Text(String::from("blue")),
//         SpreadsheetCell::Float(10.12),
//     ];
// }


// Пример 10

// Подобно структурам struct, вектор высвобождает свою память когда выходит из области видимости

// fn main() {
//     {
//         let v = vec![1, 2, 3, 4];

//         // do stuff with v
//     } // <- v goes out of scope and is freed here
// }


// Пример 11

// Использование метода push для добавления значений в вектор

// Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление 
// значений, которые он содержит. Средство проверки заимствования гарантирует, что любые ссылки на содержимое 
// вектора используются только тогда, когда сам вектор действителен.

// fn main() {
//     let mut v = Vec::new();

//     v.push(5);
//     v.push(6);
//     v.push(7);
//     v.push(8);
// }
