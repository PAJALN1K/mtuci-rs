// Пример 1

// В качестве другого примера приведём код, взятый из аудио декодера. Алгоритм декодирования 
// использует математическую операцию линейного предсказания для оценки будущих значений на основе 
// линейной функции предыдущих выборок. Код использует комбинирование вызовов итератора для выполнения 
// математических вычислений для трёх переменных в области видимости: срез данных buffer, массив из 
// 12 коэффициентов coefficients и число для сдвига данных в переменной qlp_shift. Переменные 
// определены в примере, но не имеют начальных значений. Хотя этот код не имеет большого значения вне 
// контекста, он является кратким, реальным примером того, как Rust переводит идеи высокого уровня в 
// код низкого уровня.

// fn main() {
//     let buffer: &mut [i32];
//     let coefficients: [i64; 12];
//     let qlp_shift: i16;

//     for i in 12..buffer.len() {
//         let prediction = coefficients.iter()
//                                     .zip(&buffer[i - 12..i])
//                                     .map(|(&c, &s)| c * s as i64)
//                                     .sum::<i64>() >> qlp_shift;
//         let delta = buffer[i];
//         buffer[i] = prediction as i32 + delta;
//     }
// }

fn main() {}
