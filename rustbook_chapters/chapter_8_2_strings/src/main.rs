// Когда Rustaceans говорят о "строках" то, они обычно имеют в виду типы String или 
// строковые срезы &str, а не просто один из них. Хотя этот раздел в основном посвящён 
// String, оба типа интенсивно используются в стандартной библиотеке Rust, оба, и String 
// и строковые срезы, кодируются в UTF-8.


// Пример 1

// Создание новой пустой String строки

// Многие из тех же операций, которые доступны Vec<T> , доступны также в String, потому что String 
// фактически реализован как обёртка вокруг вектора байтов с некоторыми дополнительными гарантиями, 
// ограничениями и возможностями.

// fn main() {
//     let mut s = String::new();
// }


// Пример 2

// Использование метода to_string для создания экземпляра типа String из строкового литерала

// Метод to_string доступен для любого типа

// fn main() {
//     let data = "initial contents";

//     let s = data.to_string();

//     // the method also works on a literal directly:
//     let s = "initial contents".to_string();
// }


// Пример 3

// Использование функции String::from для создания экземпляра типа String из строкового литерала

// fn main() {
//     let s = String::from("initial contents");
// }


// Пример 4

// Добавление среза строки к String используя метод push_str

// fn main() {
//     let mut s = String::from("foo");
//     s.push_str("bar");
// }


// Пример 5

// Строка String может увеличиваться в размере, а её содержимое может меняться, по аналогии как содержимое 
// Vec<T> при вставке в него большего количества данных. Кроме того, можно использовать оператор + или макрос 
// format! для объединения значений String.


// Пример 6

// Использование фрагмента строки после его добавления в состав другого String

// Если метод push_str стал бы владельцем переменнойs2, мы не смогли бы напечатать его значение в 
// последней строке. 

// fn main() {
//     let mut s1 = String::from("foo");
//     let s2 = "bar";
//     s1.push_str(s2);
//     println!("s2 is {s2}");
// }


// Пример 7

// Метод push принимает один символ в качестве параметра и добавляет его к String.

// В результате s будет содержать lol.

// fn main() {
//     let mut s = String::from("lo");
//     s.push('l');
// }


// Пример 8

// Использование оператора + для объединения двух значений String в новое String значение

// fn main() {
//     let s1 = String::from("Hello, ");
//     let s2 = String::from("world!");
//     let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
// }

// Строка s3 будет содержать Hello, world!. Причина того, что s1 после добавления больше недействительна и 
// причина, по которой мы использовали ссылку на s2 имеют отношение к сигнатуре вызываемого метода при 
// использовании оператора +. Оператор + использует метод add, чья сигнатура выглядит примерно так:
// fn add(self, s: &str) -> String {

// Перед s2 мы видим &, что означает что мы складываем ссылку на вторую строку с первой строкой. 
// Это происходит из-за параметра s в функции add: мы можем добавить только &str к String; мы не можем сложить 
// два значения String. Но подождите — тип &s2 это &String, а не &str, как определён второй параметр в add. 
// Так почему код в примере 8 компилируется?

// Причина, по которой мы можем использовать &s2 в вызове add заключается в том, что компилятор может 
// принудительно привести (coerce) аргумент типа &String к типу &str. Когда мы вызываем метод add в Rust 
// используется принудительное приведение (deref coercion), которое превращает &s2 в &s2[..]. 


// Пример 9

// Для более сложного комбинирования строк можно использовать макрос format!:

// fn main() {
//     let s1 = String::from("tic");
//     let s2 = String::from("tac");
//     let s3 = String::from("toe");

//     let s = format!("{s1}-{s2}-{s3}");
// }


// Пример 10

// Попытка использовать синтаксис индекса со строкой

// Этот код приведёт к ошибке.

// Ошибка и примечание говорит, что в Rust строки не поддерживают индексацию

// Хранение строк в Rust происходит таким замысловатым образом, что в целом, ни индексы, ни срезы к ним
// применять не стоит.

// fn main() {
//     let s1 = String::from("hello");
//     let h = s1[0];
// }


// Пример 11

// Лучший способ работать с фрагментами строк - чётко указать, нужны ли вам символы или байты. Для отдельных 
// скалярных значений в Юникоде используйте метод chars.
// Выведет это
// З
// д

fn main() {
    for c in "Зд".chars() {
        println!("{}", c);
    }
}


// Пример 12

// Метод bytes возвращает каждый байт, который может быть подходящим в другой предметной области.

// Выведет это:
// 208
// 151
// 208
// 180

// fn main() {
//     for b in "Зд".bytes() {
//         println!("{}", b);
//     }
// }

