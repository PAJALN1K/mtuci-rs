// Структура (struct) — это пользовательский тип данных, позволяющий назвать и упаковать вместе
// несколько связанных значений, составляющих значимую логическую группу. Если вы знакомы с
// объектно-ориентированными языками, структура похожа на атрибуты данных объекта.
// Мы продемонстрируем, как определять структуры и создавать их экземпляры.

// Структуры и перечисления являются строительными блоками для создания новых типов в предметной
// области вашей программы. Они дают возможность в полной мере воспользоваться преимуществами
// проверки типов во время компиляции Rust.


// Пример 1

// Структуры похожи на кортежи, рассмотренные в разделе "Кортежи", так как оба хранят несколько
// связанных значений. Как и кортежи, части структур могут быть разных типов. В отличие от кортежей,
// в структуре необходимо именовать каждую часть данных для понимания смысла значений.

// Каждая пара имя: тип называется полем.

// Пример 1

// Сама структура

struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

// Экземпляр структуры
// Пары ключ: значение, где ключами являются имена полей, а значениями являются
// данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления
// полей в описании структуры (но всё-таки желательно для удобства чтения).

fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}

// Получение из структуры какого-либо значения
// Если экземпляр является изменяемым, мы можем поменять значение, используя точечную нотацию и присвоение к конкретному полю.
// Стоит отметить, что весь экземпляр структуры должен быть изменяемым

// fn main() {
//     let mut user1 = User {
//         active: true,
//         username: String::from("someusername123"),
//         email: String::from("someone@example.com"),
//         sign_in_count: 1,
//     };
//
//     user1.email = String::from("anotheremail@example.com");
// }


// Пример 2

// Функция build_user, которая принимает email и имя пользователя и возвращает экземпляр User

// fn build_user(email: String, username: String) -> User {
//     User {
//         active: true,
//         username: username,
//         email: email,
//         sign_in_count: 1,
//     }
// }


// Пример 3

// Синтаксис сокращённой инициализации

// Функция build_user, использующая сокращённую инициализацию поля, когда параметры email и
// username имеют те же имена, что и поля struct

// fn build_user(email: String, username: String) -> User {
//     User {
//         active: true,
//         username,
//         email,
//         sign_in_count: 1,
//     }
// }


// Пример 4

// Синтаксис обновления структуры

// Создание нового экземпляра User в user2 без синтаксиса обновления.

// fn main() {
//     let user1 = User {
//         active: true,
//         username: String::from("someusername123"),
//         email: String::from("someone@example.com"),
//         sign_in_count: 1,
//     };
//
//     let user2 = User {
//         active: user1.active,
//         username: user1.username,
//         email: String::from("another@example.com"),
//         sign_in_count: user1.sign_in_count,
//     };
// }

// Создание нового экземпляра User в user2 с синтаксисом обновления.

// В этом примере мы больше не можем использовать user1 после создания user2, потому что String в
// поле username из user1 было перемещено в user2. Если бы мы задали user2 новые значения String для
// email и username, и при этом использовать только значения active и sign_in_count из user1,
// то user1 все ещё будет действительным после создания user2. Типы active и sign_in_count являются
// типами, реализующими типаж Copy.

// fn main() {
//     let user1 = User {
//         active: true,
//         username: String::from("someusername123"),
//         email: String::from("someone@example.com"),
//         sign_in_count: 1,
//     };
//
//     let user2 = User {
//         email: String::from("another@example.com"),
//         ..user1
//     };
// }


// Пример 5

// Кортежные структуры.
// Кортежные структуры обладают дополнительным смыслом, который даёт имя структуры, но при этом не
// имеют имён, связанных с их полями. Скорее, они просто хранят типы полей.

// struct Color(i32, i32, i32);
// struct Point(i32, i32, i32);
//
// fn main() {
//     let black = Color(0, 0, 0);
//     let origin = Point(0, 0, 0);
// }
//
// // Обратите внимание, что значения black и origin — это разные типы, потому что они являются
// // экземплярами разных кортежных структур. Экземпляры кортежных структур похожи на кортежи в том смысле,
// // что вы можете деструктурировать их на отдельные части и использовать ., за которой следует
// // индекс для доступа к отдельному значению.


// Пример 6

// Единично-подобные структуры: структуры без полей

// Единично-подобные структуры могут быть полезны, когда требуется реализовать типаж для
// некоторого типа, но у вас нет данных, которые нужно хранить в самом типе.

// struct AlwaysEqual;
//
// fn main() {
//     let subject = AlwaysEqual;
// }

// Представим, что в дальнейшем мы реализуем поведение для этого типа таким образом, что каждый
// экземпляр AlwaysEqual всегда будет равен каждому экземпляру любого другого типа, возможно,
// с целью получения ожидаемого результата для тестирования.


// Пример 7

// В определении структуры User в листинге 5-1 мы использовали владеющий тип String вместо типа
// строковый срез &str. Это осознанный выбор, поскольку мы хотим, чтобы каждый экземпляр этой
// структуры владел всеми своими данными и чтобы эти данные были действительны до тех пор,
// пока действительна вся структура.

// Структуры также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого
// необходимо использовать возможность Rust время жизни, которую мы обсудим в главе 10.
// Время жизни гарантирует, что данные, на которые ссылается структура, будут действительны до
// тех пор, пока существует структура. Допустим, если попытаться сохранить ссылку в структуре
// без указания времени жизни, как в следующем примере; это не сработает:

// struct User {
//     active: bool,
//     username: &str,
//     email: &str,
//     sign_in_count: u64,
// }
//
// fn main() {
//     let user1 = User {
//         email: "someone@example.com",
//         username: "someusername123",
//         active: true,
//         sign_in_count: 1,
//     };
// }

// Компилятор будет жаловаться на необходимость определения времени жизни ссылок.
