// Чтобы вызвать функцию, нам нужно знать её путь.

// Пути бывают двух видов:
// - абсолютный путь - это полный путь, начинающийся от корневого модуля крейта; для кода из 
// внешнего крейта абсолютный путь начинается с имени крейта, а для кода из текущего крейта 
// он начинается с литерала crate.
// - относительный путь начинается с текущего модуля и использует ключевые слова self, super 
// или идентификатор в текущем модуле.

// Как абсолютные, так и относительные, пути состоят из одного или нескольких идентификаторов, 
// разделённых двойными двоеточиями (::).


// Пример 1

// Вызов функции add_to_waitlist с использованием абсолютного и относительного пути

// Вернёмся к примеру 2 (глава 7-2), скажем, мы хотим вызвать функцию add_to_waitlist. Это то 
// же самое, что спросить: какой путь у функции add_to_waitlist? 

// Эти пути правильные, но остаётся ещё одна проблема, которая 
// не позволит этому примеру скомпилироваться как есть. 

// Функция eat_at_restaurant является частью общедоступного API нашего библиотечного крейта, 
// поэтому мы помечаем её ключевым словом pub. В разделе "Раскрываем приватные пути с помощью 
// ключевого слова pub" мы рассмотрим более подробно pub.

// src/lib.rs

mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

// При первом вызове функции add_to_waitlist из eat_at_restaurant мы используем абсолютный 
// путь. Функция add_to_waitlist определена в том же крейте, что и eat_at_restaurant, и это означает, 
// что мы можем использовать ключевое слово crate в начале абсолютного пути. Затем мы добавляем 
// каждый из последующих дочерних модулей, пока не составим путь до add_to_waitlist.

// Второй раз, когда мы вызываем add_to_waitlist из eat_at_restaurant, мы используем относительный 
// путь. Путь начинается с имени модуля front_of_house, определённого на том же уровне дерева модулей, 
// что и eat_at_restaurant

// Сообщения об ошибках говорят о том, что модуль hosting является приватным. Другими словами, у нас 
// есть правильные пути к модулю hosting и функции add_to_waitlist, но Rust не позволяет нам использовать 
// их, потому что у него нет доступа к приватным разделам. В Rust все элементы (функции, методы, структуры, 
// перечисления, модули и константы) по умолчанию являются приватными для родительских модулей. Если вы 
// хотите сделать элемент, например функцию или структуру, приватным, вы помещаете его в модуль.

// Элементы в родительском модуле не могут использовать приватные элементы внутри дочерних модулей, 
// но элементы в дочерних модулях могут использовать элементы у своих модулях-предках.


// Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на 
// основании вашего проекта. Решение должно зависеть от того, с какой вероятностью вы переместите 
// объявление элемента отдельно от или вместе с кодом использующим этот элемент. Например, в случае 
// перемещения модуля front_of_house и его функции eat_at_restaurant в другой модуль с именем 
// customer_experience, будет необходимо обновить абсолютный путь до add_to_waitlist, но относительный путь 
// всё равно будет действителен. Однако, если мы переместим отдельно функцию eat_at_restaurant в модуль 
// с именем dining, то абсолютный путь вызова add_to_waitlist останется прежним, а относительный путь 
// нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще п
// еремещать определения кода и вызовы элементов независимо друг от друга.



// Пример 2

// Мы хотим, чтобы функция eat_at_restaurant из родительского модуля имела доступ к функции 
// add_to_waitlist в дочернем модуле, поэтому мы помечаем модуль hosting ключевым словом pub

// src/lib.rs. Не скомпилируется

mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

// Добавление ключевого слова pub перед mod hosting сделало модуль общедоступным. После этого 
// изменения, если мы можем получить доступ к модулю front_of_house, то мы можем получить доступ 
// к модулю hosting. Но содержимое модуля hosting всё ещё является приватным: превращение модуля 
// в общедоступный модуль не делает его содержимое общедоступным. 


// Пример 3

// Добавление ключевого слова pub к mod hosting и к fn add_to_waitlist позволяет нам вызывать функцию из eat_at_restaurant

mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

// В случае абсолютного пути мы начинаем с crate, корня дерева модулей нашего крейта. Модуль 
// front_of_house определён в корневом модуле крейта. Хотя front_of_house не является общедоступным, 
// но поскольку функция eat_at_restaurant определена в том же модуле, что и front_of_house (то есть, 
// eat_at_restaurant и front_of_house являются потомками одного родителя), мы можем ссылаться на 
// front_of_house из eat_at_restaurant. Далее идёт модуль hosting, помеченный как pub. Мы можем 
// получить доступ к родительскому модулю модуля hosting, поэтому мы можем получить доступ и к 
// hosting. Наконец, функция add_to_waitlist помечена как pub, и так как мы можем получить 
// доступ к её родительскому модулю, то вызов этой функции разрешён!

// В случае относительного пути логика такая же как для абсолютного пути, за исключением первого шага: 
// вместо того, чтобы начинать с корневого модуля крейта, путь начинается с front_of_house.



// Начинаем относительный путь с помощью super

// Пример 4

// Также можно построить относительные пути, которые начинаются в родительском модуле, используя ключевое
// слово super в начале пути. Это похоже на синтаксис начала пути файловой системы .. . Использование super 
// позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском модуле, что может 
// упростить переупорядочение дерева модулей, чем когда модуль тесно связан с родителем, но родитель может 
// когда-нибудь быть перемещён в другое место в дереве модулей.

fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}

// Функция fix_incorrect_order вызывает функцию deliver_order, определённую в родительском модуле, указывая 
// путь к deliver_order, начинающийся с super

// Функция fix_incorrect_order находится в модуле back_of_house, поэтому мы можем использовать super для 
// перехода к родительскому модулю модуля back_of_house, который в этом случае является crate, корневым модулем. 
// В этом модуле мы ищем deliver_order и находим его. Успех! Мы думаем, что модуль back_of_house и функция 
// deliver_order, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут 
// перемещены вместе, если мы решим реорганизовать дерево модулей крейта. Поэтому мы использовали super, чтобы 
// в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой модуль.



// Делаем общедоступными структуры и перечисления

// Пример 5

// Мы также можем использовать pub для обозначения структур и перечислений как общедоступных, но есть несколько 
// дополнительных деталей использования pub со структурами и перечислениями. Если мы используем pub перед определением 
// структуры, мы делаем структуру общедоступной, но поля структуры по-прежнему остаются приватными. Мы можем сделать 
// каждое поле общедоступным или нет в каждом конкретном случае. В листинге 7-9 мы определили общедоступную структуру 
// back_of_house::Breakfast с общедоступным полем toast и с приватным полем seasonal_fruit. Это моделирует случай в 
// ресторане, когда клиент может выбрать тип хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают 
// еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут 
// выбирать фрукты или даже увидеть, какие фрукты они получат.

// Файл: src/lib.rs

mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}

// Также обратите внимание, что поскольку back_of_house::Breakfast имеет приватное поле, то структура должна предоставить 
// публичную ассоциированную функцию, которая создаёт экземпляр Breakfast (мы назвали её summer). Если Breakfast не имел бы 
// такой функции, мы бы не могли создать экземпляр Breakfast внутри eat_at_restaurant, потому что мы не смогли бы установить 
// значение приватного поля seasonal_fruit в функции eat_at_restaurant.


// Пример 6

// В отличии от структуры, если мы сделаем общедоступным перечисление, то все его варианты будут общедоступными.

// mod back_of_house {
//     pub enum Appetizer {
//         Soup,
//         Salad,
//     }
// }

// pub fn eat_at_restaurant() {
//     let order1 = back_of_house::Appetizer::Soup;
//     let order2 = back_of_house::Appetizer::Salad;
// }


